---
title: "Questions about FXTAS Sequence Data"
format:
  html:
    toc: true
    toc-depth: 4
    toc-float: true
    number-sections: true
    embed-resources: true
  docx:
    number-sections: true
---

```{r, include = FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  fig.width = 7.5,
  fig.height = 4
)

# update 'asis' chunk to allow inline code
knitr::knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knitr::knit_child(text = options$code)
})
```

```{r setup}
#| message: false
library(fxtas)
devtools::load_all()
library(pander)
library(table1)
library(dplyr)
library(magrittr)
library(DT) # potentially update required/suggested packages
NA.label1 = "Missing"
column_var = "Recruited in study phase"
column_var = "FX**"
# load_all()

phase <- ifelse(column_var == "Recruited in study phase", TRUE, FALSE)
cgg <- ifelse(column_var == "FX**", TRUE, FALSE)
```

# General data processing notes

## Missing codes

The missing codes 777, 888, and 999 were converted to `NA` for all variables, unless noted otherwise below.

## Age of onset

In the RedCap database, the "age of onset" variables were recorded using a mix of precise ages and decade-long ranges (for example, "`130`" = "teens", "`200`" = "twenties", etc.). For analysis as numeric variables, the decade codes were replaced by their midpoints (for example, "`130`" was replaced with 15, "`200`" with 25, etc.). The exception is code "`555`" = "lifelong", which was replaced by the minimum of 10 years and the smallest observed value for that age-of-onset variable; for example, if the smallest observed value for "age of tremor onset" was 8, then "`555`" would be replaced by 9. If the smallest observed value were 11, then "`555`" would be replaced by 10.

# Data from first visits

```{asis, echo=phase}
Here, we review the data from the first visits by each participant, stratified by 
the first study phase in which the participant enrolled (GP3 vs GP4).
```

```{asis, echo=cgg}
Here, we review the data from the first visits by each participant, stratified by CGG (`r paste0("<55 or", " \u2265", "55")`).
```


## Demographics

There is substantial missingness in both `Primary Ethnicity` and `Primary Race`; not sure if we will need these variables:  


Primary ethnicity we can drop. Primary race we may be able to look on Randi’s cards for that or ask her. There are only 44 to look up. 

```{r}

vars = c(
  "Age at first visit",
  "# visits",
  # column_var,
  "Gender",
  "Primary Ethnicity",
  "Primary Race"
  
)

table1(
  NA.label = NA.label1,
  stratified_formula(vars, column_var),
  # render.continuous = c(.="N", .="Mean (SD)", .="Median [Min,  Max]"),
  data = visit1)
```


## Study

```{r}
table1(
  NA.label = NA.label1,
  formula(paste(
    "~", paste(formulaic::add.backtick("Study"), collapse = " + "), 
    "|",
    column_var |> formulaic::add.backtick())),
  data = visit1)
```

## APOE

```{r}
apoe.n = gp34 |> missing_pattern_by_ID(variable = "ApoE")

```

Many participants (`r sum(apoe.n$first_missing)` of `r nrow(apoe.n)`) have ApoE missing in their first visit records:

```{r}
vars = grep("^ApoE", names(gp34), value = TRUE)
table1(
  NA.label = NA.label1,
  
  paste(
    "~", 
    paste(
      formulaic::add.backtick(vars), 
      collapse = " + "), 
    "|",
    column_var |> formulaic::add.backtick()) |> 
    formula(),
  # render.missing=c("Empty in RedCap"="FREQ (PCT%)"),
  data = visit1)
```


`r apoe.n |> filter(first_missing) |> pull(any_nonmissing) |> sum()` of these individuals have later visits with non-missing ApoE results; for example:

```{r}

gp34 |> filter(
  # `FXS ID` == "500011-122"
  `FXS ID` == apoe.n |> filter(first_missing, any_nonmissing) |> head(1) |> pull(`FXS ID`)
) |> 
  select(`FXS ID`, `Event Name`, `Visit Date`, ApoE) |> 
  pander()

```

**QUESTION:** Is it reasonable to use the next non-missing ApoE result to impute the ApoE results for the earlier visit? Note that in some cases, the ApoE value changes between visits:

If they are missing, it is reasonable to use the next available result. The issue with differences between visits will need to be addressed with Flora; the samples may have been run differently between visit leading to different APoE values. 

```{r, "multiple ApoE values", results = "asis"}

gp34 |> 
  semi_join(apoe.n |> filter(n_vals > 1), by = "FXS ID") |> 
  select(`FXS ID`, `Visit Date`, `Event Name` ,ApoE) |> 
  arrange(`FXS ID`, `Visit Date`) |> 
  split(~`FXS ID`) |> 
  pander()

```


List of patients with missing ApoE data:

```{r}
apoe_na <- gp34 |> 
  semi_join(apoe.n |> filter(n_vals == 0), by = "FXS ID") |> 
  select(`FXS ID`, `Visit Date`, `Event Name` ,ApoE) |> 
  arrange(`FXS ID`, `Visit Date`)
```


```{r, results='asis'}
DT::datatable(
  apoe_na, rownames = FALSE,
  extensions = c('Buttons', "RowGroup"),
  options = list(
    dom = 'Bfrtip',
    # columnDefs = list(
    #   list(
    #     visible=FALSE,
    #     targets=c(0)
    #   )
    # ),
    buttons = list(
      list(
        extend = 'collection',
        buttons = list(
          list(
            extend = 'csv',
            filename = "GP3_GP4_Missing_ApoE"
          ),
          list(
            extend = 'excel',
            filename = "GP3_GP4_Missing_ApoE"
          )
        ),
        text = "Download"
      )
    ),
    rowGroup = list(dataSrc = 0)
  )
)

```

## CGG

```{r}
cgg.n = gp34 |> missing_pattern_by_ID(variable = "CGG")
```

There's a lot of missing data in CGG as well:

```{r}

vars = grep("^CGG", names(gp34), value = TRUE)

table1(
  NA.label = NA.label1,
  formula(paste(
    "~", paste(formulaic::add.backtick(vars), collapse = " + "), 
    "|",
    column_var |> formulaic::add.backtick())),
  # render.continuous = c(.="N", .="Mean (SD)", .="Median [Min,  Max]"),
  data = visit1)
```

`r cgg.n |> filter(first_missing) |> pull(any_nonmissing) |> sum()` of these participants have later records with non-missing CGG values:

```{r}

gp34 |> 
  semi_join(
    cgg.n |> 
      filter(
        first_missing,
        any_nonmissing), 
    by = "FXS ID") |> 
  select(`FXS ID`, `Visit Date`, `Event Name` , CGG) |> 
  arrange(`FXS ID`, `Visit Date`) |> 
  split(~`FXS ID`) |> 
  pander()
```


Some participants have multiple CGG values:  

**Question:** can we fill in the earlier values using later values?

Yes this is reasonable. Shouldn’t change between visits.  
From Randi: use later versions if inconsistent, might change due to improvements in assays. 

```{r, "multiple CGG values", include = TRUE, results = "asis"}

gp34 |> 
  semi_join(
    cgg.n |> 
      filter(
        n_vals > 1), 
    by = "FXS ID") |> 
  select(`FXS ID`, `Visit Date`, `Event Name` , CGG) |> 
  arrange(`FXS ID`, `Visit Date`) |> 
  split(~`FXS ID`) |> 
  pander()

```

List of patients with missing CGG data:  

```{r, include = TRUE}
# check fxtas stage where CGG is missing
cgg_na <- gp34 |> 
  semi_join(
    cgg.n |> 
      filter(
        n_vals == 0), 
    by = "FXS ID") |> 
  select(`FXS ID`, `Visit Date`, `Event Name` , CGG) |> 
  arrange(`FXS ID`, `Visit Date`)

```


```{r}
DT::datatable(
  cgg_na, rownames = FALSE,
  extensions = c('Buttons', 'RowGroup'),
  options = list(
    dom = 'Bfrtip',
    buttons = list(
      list(
        extend = 'collection',
        buttons = list(
          list(
            extend = 'csv',
            filename = "GP3_GP4_Missing_CGG"
          ),
          list(
            extend = 'excel',
            filename = "GP3_GP4_Missing_CGG"
          )
        ),
        text = "Download"
      )
    ),
    rowGroup = list(dataSrc = 0)
  )
)

```


