---
title: "Event sequences in Fragile X-associated tremor/ataxia syndrome"
knitr:
  opts_chunk: 
    collapse: true
    comment: "#>" 
    R.options:  
      dev: svg

project:
  execute-dir: project
---

```{=html}
<style>
.quarto-figure-center > figure {
  text-align: center;
}
</style>
```

# Introduction

Here, we apply the Ordinal **Su**btype and **St**age **In**ference ("SuStaIn") algorithm [@young2021ordinal] to find event sequences for FXTAS patients.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  # fig.width = 7, 
  # fig.height = 10,
  include = TRUE
)
```

```{r setup}
#| message: false
# devtools::load_all()
library(fxtas)
reticulate::use_condaenv("fxtas39",required = TRUE)
library(tidyverse)
library(reticulate)
library(pander)
```

```{r}
# reticulate::use_condaenv(condaenv = "fxtas")
```

```{r}
#| label: "set run parameters"
#| 
fit_models = TRUE
# fit_models = FALSE
run_CV =  TRUE
# run_CV = FALSE

N_startpoints = 10L
N_S_max = 5L
N_S_max_stratified = 1L
N_CV_folds = 10L
N_iterations_MCMC = 1e5L
dataset_name = 'sample_data'
root_dir = here::here()
setwd(root_dir)
output_folder = 
  "output/output.longest" |> 
  fs::dir_create()
```

# Methods

## Data

The data come from the GP and GP4 studies. We analyzed one visit record per participant, using the earliest visit available across the two studies with age at visit $\ge 40$ years, resulting in `r nrow(visit1)` observations in total. However, `r visit1$"FX*" |> is.na() |> sum()` individuals did not have CGG values available, so only `r visit1$"FX*" |> Negate(is.na)() |> sum()` individuals 
(`r (visit1$"FX**" == "CGG >= 55")|> sum()` cases and 
`r (visit1$"FX**" == "CGG < 55")|> sum()` controls) were included in the event sequence analysis.

```{r}

biomarker_groups = compile_biomarker_groups_table()

SuStaInLabels = 
  biomarker_varnames = 
  biomarker_groups |> 
  pull("biomarker")


df = 
  visit1 |> 
  filter(
    !is.na(`FX*`))

biomarker_levels = 
  lapply(df[,biomarker_varnames], F = levels)

df = df |>
  mutate(
    across(
      all_of(biomarker_varnames), 
      ~ as.integer(.x) - 1),
    Diagnosis = as.integer(`FX*` == "CGG >= 55"))

biomarker_events_table =
  construct_biomarker_events_table(
    biomarker_levels,
    biomarker_groups)

nlevs = 
  biomarker_levels |> sapply(length)

```

We analyzed `r length(biomarker_levels)` biomarkers (@tbl-biomarker-list) with a total of `r nrow(biomarker_events_table)` non-baseline levels; each level above baseline constitutes an outcome event in the disease progression modelling analysis (@sec-Statistical-analysis).

```{r}
#| tbl-cap: "Biomarkers used in analysis"
#| label: "tbl-biomarker-list"
table_out =
  biomarker_events_table |> 
  select(category = biomarker_group, biomarker, levels) |> 
  slice_head(by = biomarker)

table_out |> 
  pander()

```

The trailing asterisk (*) indicates a numeric variable that has been categorized for use with Ordinal SusTaIn.

## Statistical analysis {#sec-Statistical-analysis}

We applied  the Ordinal **Su**btype and **St**age **In**ference ("SuStaIn") algorithm [@young2018uncovering; @young2021ordinal] to our dataset to find event sequences and subgroupings for FXTAS patients. This algorithm combines disease progression modelling [@fonteijn2012event] and unsupervised clustering to model event onset sequences using a cross-sectional sample of a patient population. The algorithm simultaneously clusters individuals into subgroups and characterizes the trajectory that best defines each subgroup, thus capturing heterogeneity in both disease subtype and disease stage.

Ordinal SuStaIn uses Markov Chain Monte Carlo (MCMC) sampling to estimate the Bayesian posterior probability of each possible event sequence for each subgroup given the training dataset, assuming a uniform prior distribution over the set of all possible patterns. 

We first fit the model on the full GP+GP4 dataset, assuming one shared event sequence (no latent subgroups; see @fig-pvd1-1).

We also fit the model stratified by sex (again with no latent subgroups; one event sequence per per sex; see @fig-pvd1-2 and @fig-pvd1-3).

We also fit the model stratified by CGG repeats (<100 vs $\ge$ 100), also with no latent subgroups (see @fig-pvd-by-cgg).

We also fit the model on the full dataset (not stratified by sex or CGG) for 2-6 latent subgroups, each with their own ordering (@fig-pvd4). We determined the optimal number of latent subgroups for this dataset using the CVIC criterion (@sec-cvic). 

### Visualizing modeling results

We visualized the results of Ordinal SuStaIn analysis using "positional variance diagrams" (PVDs), which are heatmaps with biomarker events on the y-axis and sequence positions on the x-axis. The PVD's color scale indicates the Bayesian posterior probability that the biomarker events listed on the y-axis occur in the sequence positions listed on the x-axis: red indicates a more probable sequence position, and gray indicates a less probable position.

```{r}

ModelScores = DataScores = 
  df |> 
  select(all_of(biomarker_varnames)) |> 
  # lapply(F = levels)
  compute_score_levels()


control_data = 
  df |> 
  filter(`FX*` == "CGG < 55") |> 
  select(all_of(biomarker_varnames))

patient_data = 
  df |> 
  # na.omit() |>
  filter(`FX*` == "CGG >= 55")

prob_correct = 
  control_data |> 
  compute_prob_correct(
    max_prob = .95,
    biomarkers = biomarker_varnames,
    DataScores = DataScores)

prob_score0 = compute_prob_scores(
    dataset = patient_data,
    biomarker_varnames,
    ModelScores = ModelScores,
    DataScores = DataScores,
    prob_correct = prob_correct
  )
 
prob_nl = prob_score0[,,1]
prob_score = prob_score0[,,-1, drop = FALSE]

```

```{r "score_vals"}

# sapply(X = biomarker_varnames, F = function(x) 1:nlevs[x])

score_vals = matrix(
  ModelScores[-1] |> as.numeric(),
  byrow = TRUE,
  nrow = length(biomarker_varnames),
  ncol = length(ModelScores) - 1,
  dimnames = list(biomarker_varnames, ModelScores[-1]))

for (i in biomarker_varnames)
{
  score_vals[i,score_vals[i,] > nlevs[i]-1] = 0
}

save.image(file = fs::path(output_folder, "data.RData"))

```

```{r "run OSA from R"}
#| message: false
#| label: model-all-data
#| include: false
sustain_output = run_OSA(
  prob_score = prob_score0,
  score_vals = score_vals,
  SuStaInLabels = SuStaInLabels,
  N_startpoints = N_startpoints,
  N_S_max = N_S_max, 
  N_iterations_MCMC = N_iterations_MCMC, 
  output_folder = output_folder, 
  dataset_name = dataset_name, 
  use_parallel_startpoints = FALSE,
  seed = 1,
  plot = FALSE,
  patient_data = patient_data,
  N_CV_folds = N_CV_folds)

```

```{r}
#| message: false
#| label: model-males
#| include: false
sustain_output_males = run_OSA(
  prob_score = prob_score0[patient_data$Gender %in% "Male",,],
  score_vals = score_vals,
  SuStaInLabels = SuStaInLabels,
  N_startpoints = N_startpoints,
  N_S_max = N_S_max_stratified, 
  N_iterations_MCMC = N_iterations_MCMC, 
  output_folder = output_folder, 
  dataset_name = "males", 
  use_parallel_startpoints = FALSE,
  seed = 1,
  plot = FALSE)

```


```{r}
#| message: false
#| label: model-females
#| include: false
sustain_output_females = run_OSA(
  prob_score = prob_score0[patient_data$Gender %in% "Female",,],
  score_vals = score_vals,
  SuStaInLabels = SuStaInLabels,
  N_startpoints = N_startpoints,
  N_S_max = N_S_max_stratified, 
  N_iterations_MCMC = N_iterations_MCMC, 
  output_folder = output_folder, 
  dataset_name = "females", 
  use_parallel_startpoints = FALSE,
  seed = 1,
  plot = FALSE)

```


```{r}
#| message: false
#| label: "cgg_over_100"
#| include: false
sustain_output_cgg100plus = run_OSA(
  prob_score = prob_score0[
    patient_data$`CGG (backfilled)` >= 100,,],
  score_vals = score_vals,
  SuStaInLabels = SuStaInLabels,
  N_startpoints = N_startpoints,
  N_S_max = N_S_max_stratified, 
  N_iterations_MCMC = N_iterations_MCMC, 
  output_folder = output_folder, 
  dataset_name = "over100", 
  use_parallel_startpoints = FALSE,
  seed = 1,
  plot = FALSE)

```

```{r}
#| message: false
#| label: "cgg_under_100"
#| include: false
sustain_output_cgg100minus = run_OSA(
  prob_score = prob_score0[
    patient_data$`CGG (backfilled)` < 100,,],
  score_vals = score_vals,
  SuStaInLabels = SuStaInLabels,
  N_startpoints = N_startpoints,
  N_S_max = N_S_max_stratified, 
  N_iterations_MCMC = N_iterations_MCMC, 
  output_folder = output_folder, 
  dataset_name = "under100", 
  use_parallel_startpoints = FALSE,
  seed = 1,
  plot = FALSE)

```


# Results

@fig-pvd1-1 shows the event sequence model, estimated using the combined GP and GP4 data and assuming that all individuals share the same event sequence; in other words, assuming one subgroup.

@fig-pvd1-2 and @fig-pvd1-3 show estimated event sequences stratified by sex, assuming one  subgroup per sex. It appears that males experience increasing ataxia severity earlier in the event sequence than females, while females experience MRI events and SCL psychological symptoms earlier in the event sequence than males.^[There are probably other patterns worth noting here; clinical folks, let us know what you notice!]


```{r}
#| label: "fig-pvd1"
#| column: screen
#| fig-height: 15
#| fig-align: center
#| fig-cap: "Estimated event sequence models - overall and stratified by sex"
#| fig-cap-location: top
#| layout-ncol: 3
#| fig-subcap:
#|   - "All data" 
#|   - "Males"
#|   - "Females"

figs = extract_figs_from_pickle(
  n_s = 1,
  dataset_name = dataset_name,
  output_folder = output_folder) |> 
  print()

fig_male = extract_figs_from_pickle(
  n_s = 1,
  dataset_name = "males",
  output_folder = output_folder) |> 
  print()

fig_female = extract_figs_from_pickle(
  n_s = 1,
  dataset_name = "females",
  output_folder = output_folder) |> 
  print()
```

## Stratified by CGG repeats

@fig-pvd-by-cgg shows the estimated event sequence model, this time comparing the unstratified results with stratification by CGG repeats (<100 vs 100+; assuming no latent subgroups within strata). Here, we find that patients with CGG <100 experienced SCL90 events earlier in the sequence than patients with CGG $\ge$ 100.

```{r}
#| label: "fig-pvd-by-cgg"
#| column: screen
#| fig-height: 15
#| fig-align: center
#| fig-cap: "positional variance diagram assuming one subgroup - overall and stratified by CGG repeats (<100 vs 100+)"
#| fig-cap-location: top
#| layout-ncol: 2
#| fig-subcap:
#|   - "CGG < 100"
#|   - "CGG 100+"

fig_under100 = extract_figs_from_pickle(
  n_s = 1,
  dataset_name = "under100",
  output_folder = output_folder) |> 
  print()

fig_over100 = extract_figs_from_pickle(
  n_s = 1,
  dataset_name = "over100",
  output_folder = output_folder) |> 
  print()

```


## Latent subgroups {#sec-latent-subgroups}

```{r}
n_s = 4
```

Based on the CVIC criterion (@sec-cvic), it appears that `r n_s` subgroups is the optimal number for the full, unstratified GP+GP4 dataset.
@fig-pvd4 shows positional variance diagrams (PVDs) for each of the subgroup clusters detected under this assumption, and @tbl-sg_demos shows the demographics of the patients clustered in each subgroup; patients in the "Type 0" category were too early in the disease process to be classified into a subgroup.

```{r}

figs = extract_figs_from_pickle(
  n_s = n_s,
  dataset_name = dataset_name,
  output_folder = output_folder)
```

```{r}
#| label: "fig-pvd4"
#| layout-ncol: 4
#| fig-height: 15
#| fig-align: center
#| fig-cap: "positional variance diagrams for 4 subgroups"
#| fig-cap-location: top
#| column: screen
#| fig-subcap:
#|   - "Subgroup 1"
#|   - "Subgroup 2"
#|   - "Subgroup 3"
#|   - "Subgroup 4"
library(ggplot2)

figs |> 
  print_PVDs()

```

```{r}
#| tbl-cap: !expr glue::glue("Subgroup demographics ({n_s} subgroups)")
#| label: tbl-sg_demos
#| results: asis

results = extract_results_from_pickle(
  n_s = n_s,
  dataset_name = dataset_name,
  output_folder = output_folder,
  biomarker_groups = biomarker_groups,
  biomarker_levels = biomarker_levels)

table_subtype_by_demographics(
    patient_data,
    subtype_and_stage_table = results$subtype_and_stage_table
    )
```

# Discussion

[to be added]

# References {.unnumbered}

::: {#refs}
:::

# Appendix {.appendix}

## Detecting latent subgroups {#sec-subgroups}

In order to the Ordinal SuStaIn algorithm, we must specify how many latent subgroups to model. There are several metrics for determining the optimal number of subgroups for a given data set.

### Likelihood

The simplest option is to compare the likelihood of the data for the fitted model while varying the number of subgroups used to fit the model. @fig-mcmc-loglik shows the distribution of log-likelihoods from the MCMC samples for the full dataset (not stratified by sex or CGG repeats). Adding up to 6 clusters substantially improves the log-likelihood.

```{r}
#| fig-height: 4
#| label: fig-mcmc-loglik
#| fig-cap: log-likelihoods of MCMC samples, by number of subtypes
#| eval: !expr fit_models
sustain_output$samples_likelihood |>
  graph_likelihoods_v2(alpha = 0.5) |>
  suppressWarnings()

```

### Cross-Validation Information Criterion {#sec-cvic}

Since models with fewer subtypes are limited special cases of models with more subtypes (i.e., "nested models"), the likelihood of the training data is guaranteed to improve as we increase the number of subtypes. However, using too many subtypes means there is less data available for each subtype, possibly leading to a model that does not generalize well to new data (i.e., a model that is "overfit" to the training data).

To avoid overfitting, @young2018uncovering recommends choosing the optimal number using the the Cross-Validation Information Criterion (CVIC):

#### Mathematical details of cross-validation criteria {#sec-cvic-math}

Let:

* $n$ be the number of observations in the dataset
* $Y_i$ be the observed biomarker values for the $i^{th}$ participant
* $\mathcal C$ be the number of latent subtypes assumed, with corresponding index $c$.
* $C_i$ be the latent subgroup membership of observation $i$
* $\mathcal S$ be the set of possible event sequences, indexed by $\mathcal s$
* $S_c \in \mathcal S$ be the sequence for subgroup $c$
* $K$ be the number of cross-validation folds, with index $k$; typically, $K = 10$.
* $n_k$ be the number of held-out observations in cross-validation fold $K$; $n_k \approx n/K$
* $\hat{P}_{(-k)}(C = c)$ be the prior probability that an observation belongs to subgroup $c$, estimated using all observations except those in fold $k$.

Then:

$$
CVIC_{\mathcal C} = 
-2 * 
\sum_{k=1}^K 
\sum_{i=1}^{n_k} 
\log
\left\{
\sum_{c=1}^\mathcal C 
\sum_{s\in \mathcal S}
\hat P(Y_i|C_i = c, S_c=s)
\hat{P}_{(-k)}(C_i = c, S_c = s)
\right\}
$$

#### CVIC for the full GP+GP4 dataset

We performed `r N_CV_folds`-fold cross-validation on the unstratified GP+GP4 data, and calculated the CVIC for 1-6 latent subgroups.

```{r}
#| fig-cap: "Cross-validation information criterion"
#| label: fig-cvic

library(ggplot2)

temp = sustain_output |> attr("CV")
temp$CVIC |> plot_CVIC()

```

It appears that the model nearly reaches peak CVIC by 4 subgroups.

## Out-of-fold log-likelihood distribution

We also evaluated the consistency of our cross-validation procedure by looking at the distribution of test-set log-likelihood across folds (@fig-boxplot-loglik-cv); following @young2018uncovering, we calculated out-of-sample log-likelihood as:

$$
\ell_{\mathcal C, k} = 
\sum_{i = 1}^{n_k}
\sum_{c=1}^\mathcal C 
\sum_{s\in \mathcal S}
\log
\left\{
\hat P(Y_i|C_i = c, S_c=s)
\right\}
\hat{P}_{(-k)}(C_i = c, S_c = s)
$$


```{r}
#| fig-cap: "Test set log-likelihood across folds"
#| label: fig-boxplot-loglik-cv
temp$loglike_matrix |> 
  plot_cv_loglik()

```

